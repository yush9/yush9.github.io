---
title : "FPGA-Driven VGA Screen to Print Whatever You Like :)  "
date : 2025-07-21 11:28:00 +0530
categories : blog
tags : FPGA
author: <ayush>
---

# The Broad Idea

Armed with a Basys3 FPGA board and a monitor that supported VGA (don't think these are common anymore), we put together a little setup that takes in display information and gives an output of the drawing of your choice on the said monitor. 

We'll take you through the hardware set-up, the code and other nuances so that you can either recreate it for your purposes or (hopefully) take it forward :)

## Display Controller

The system relies on a verilog module programmed onto the FPGA which provides a color output, alongside horizontal and vertical sync signals. If you are new to the VGA protocol, [this is a fairly informative guide](https://embeddedthoughts.com/2016/07/29/driving-a-vga-monitor-using-an-fpga/).

We used a controller module quite similar to the one described in the article.

 `h_count` and `v_count` are registers that hold the value of which pixel our controller is currently positioned at. `H_TOTAL` and `V_TOTAL` refer to the maximum number of pixels to be traversed the respective direction (will depend on screen resolution).
 
  The logic below shows how we increment the registers, performing the action of moving across the screen.


```verilog
always @(posedge clk_25MHz or posedge reset) begin
    if (reset) begin
        h_count <= 0;
        v_count <= 0;
    end else begin
    if (h_count == H_TOTAL- 1) begin
        h_count <= 0;
        if (v_count == V_TOTAL- 1)
         v_count <= 0;
    else
    v_count <= v_count + 1;
    end 
    else 
    h_count <= h_count + 1;
 end
 ```
> There isn't actually anything 'moving' across the screen, it is simply to meet timing requirements as we are emulating a CRT. Look into VGA protocol and emulation of it for a better understanding 
{: .prompt-info }



The below code will generate the sync signals (active low). `H_FP`and `V_FP` refer to the porch pixels, and the `H_ACTIVE` and `V_ACTIVE` parameters denote the actual display pixels of the monitor in either direction.

```verilog
assign hsync = ~((h_count >= (H_ACTIVE + H_FP)) && (h_count < (H_ACTIVE + H_FP + H_SYNC)));
assign vsync = ~((v_count >= (V_ACTIVE + V_FP)) && (v_count < (V_ACTIVE + V_FP + V_SYNC)));
assign active_area = (h_count < H_ACTIVE) && (v_count < V_ACTIVE);
```

## Hardware initializations on the FPGA

Utlising some nifty features on Xilinx Vivado, we will be setting up some **block RAM (BRAM)** that will store the coordinates of the pixels that need to be lit up on the monitor. 

For example (taking the top left corner of the screen as (0,0)), if you want the centre pixel of your 640x480 screen to glow, you need to provide (320,240) as a coordinate to the RAM. 

![img-description](C:\Users\ayush\Documents\cemilac blog\yush9.github.io\assets\images\design_1 (1)_page-0001.jpg)
_Image Caption_

The Microblaze soft processor reads the coordinates from the two BRAMs (one for the x-coordinate and the other for the y) and runs some processing on it, which we will now discuss.


>  The coordinates are being passed to the BRAM as a `.coe` file. 
{: .prompt-info }

## What is this processing you speak of?

Utlising *Vitis IDE*, we will have Microblaze run some C code to convert the coordinates to a **pixel map**.

A pixel map is a term we use for a piece of memory that has its bits correspond to a pixel on the monitor. If the fourth bit in the memory is *ON*, the corresponding pixel on the screen is lit up. Similarly for all other bits and pixels.

```c
    X_in = Xil_In32( XPAR_X_COORDS_CTRL_S_AXI_BASEADDR);
    Y_in = Xil_In32(XPAR_Y_COORDS_CTRL_S_AXI_BASEADDR);
```

The soft processor reads the first coordinate from the base addresses of the BRAMs. 

```c
div = X_in/32;
packet_no = (Y_in*20) + div;	
```

